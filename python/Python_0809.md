# 코드리뷰

````
미로찾기는 문제를 읽어보고 고민만 해보고 dfs를 배우고 나서 다시 풀어보면 좋을 것
````



- 오목

  ````
  가장 왼쪽에 있는 바둑알의 위치를 출력해야 하기 때문에
  탐색 범위는 우(오른쪽)상과 우하 방향으로 탐색을 해야 한다.
  
  무승부일 경우와 육목
  ````

# 그래프(Graph)

> 정점과 이를 연결하는 간선들의 집합으로 이루어진 비선형 자료구조

```
< 목 차 >
1. 그래프에 대한 이해
2. 그래프의 종류
3. 그래프의 표현
	- 인접리스트 만들기
```

- 점(Vertex/Node)을 연결하는 선(Edge)들의 집합을 이루어진 비선형 자료구조



## 그래프 관련 용어

````
정점 : 간선으로 연결되는 객체
간선: 정점 간의 관게를 표현하는 선
경로 : 시작 정점부터 도착 정점까지 거치는 모든 정점을 나열한 것
👉 인접 : (상태)두 개의 정점이 하나의 간선으로 직접 연결된 하나의 상태
````

````
인접한 두 정점 == 서로 '직접' 연결된 정점이라는 뜻
````

- 직접 그래프를 보면서 이해하기
- 일반적으로 위계 없음, 위계가 있는 그래프 = 트리



## 그래프의 종류

1. 무방향 그래프

   > 간선의 방향이 없는 가장 일반적인 그래프

   - 간선을 통해 양방향의 정점 이동 가능

   - 차수(Degree) : 하나의 정점에 연결된 간선의 개수

   - 무방향 그래프는 서로 연결되어 있기 때문에

   - <u>어떤 엣지든 카운트 수를 두 개씩 먹는다.</u>

   - 모든 정점의 차수의 합 = 간선 수 * 2

     

2. 유방향 그래프

   >  간선의 방향이 있는 그래프

   - 간선의 방향이 가리키는 정점으로(만) 이동 가능
   - 방향이 있으면 갈 수 있는 곳이 정해져 있다
   - 진입 차수와 진출 차수로 나뉨.
     - 진입 차수 : 외부 정점에서 들어오는 간선의 수
     - 진출 차수: 한 정점에서 외부로 나가는 간선의 수



## 그래프의 표현

간선의 리스트를 해당하는 정점과 인접해있는 상태로

1. 인접 행렬

   > 정점을 연결하는 간선이 없으면 0, 있으면 1을 가지는 행렬로 표현

   - 무방향 그래프일 경우 0을 기점으로 데칼코마니

     

2. 인접 리스트

   > 리스트를 통해 **각 정점에 대한 인접 정점**들을 순차적으로 표현

   - `append()`를 활용한다.
   
   - 인접리스트는 연결된 정점만 저장하여 효율적이므로 자주 사용
   
     
   
### 인접리스트 만들기

> ```python
> 정점의 개수만큼 [빈 리스트]를 만들고 그 안에 인접 노드를 집어 넣는다.
> ```

 ```python
 # 인덱스 번호를 가져오기 위해 정점의 개수만큼 빈 리스트를 생성
 
 정점 = 7
 간선 = 7
  
 # 간선이 연결하는 두 정점의 목록(인접한 두 정점 == 서로 직접 연결된 정점)
 ================================
 0 1
 0 2
 1 3
 1 4
 2 4
 2 5
 4 6
 =================================
 graph = [[] for _ in range(정점)]
 
 # 간선의 수만큼 인접 정점 번호 리스트를 받아온다.
 
 for _ in range(간선):
     
     v1, v2 = map(int, input().split())
     
     # 받아온 인접 노드를 시작 정점과 일치한 인덱스의 빈 그래프에 추가한다.
     graph[v1].append(v2)
     
     # 무방향이라면 추가
     graph[v2].append(v1)
 
 pprint(graph)
 >>>
     [[1, 2], 
     [0, 3, 4], 
     [0, 4, 5], 
     [1], 
     [1, 2, 6], 
     [2], 
     [4]]
 
 ```


useEffect를 이용하여 컴포넌트 `Mount` 시점에 `API를 호출`하고

해당 `API의 결과값을 일기 데이터의 초기값으로` 이용한다.



- API 호출은 내장함수 `fetch`를 활용

  API의 응답을 `App.js`의 `data` state에 저장해서 일기 데이터의 초기값으로 설정



## 동기 & 비동기

- 동기방식

  > 이전 작업이 진행중일 때 다음 작업을 수행하지 않고 기다리며, 먼저 작성된 코드를 먼저 다 실행하고 나서 뒤에 작성된 코드를 실행

- 동기처리 방식의 문제점

동기적 처리의 단점은 하나의 작업이 너무 오래 걸리게 될 시,

모든 작업이 '오래 걸리는 하나의 작업'이 종료되기 전까지 올 스탑.

=> 전반적인 흐름이 느려짐



- 비동기 작업

  > 싱글 스레드 방식을 이용하면서 여러 개의 작업을 동시에 실행. 먼저 작성된 코드의 결과를 기다리지 않고 다음 코드를 바로 실행 => 논 블로킹

콜백함수를 전달해서 작업 결과에 대한 결과값을 받아옴.



setTimeout() - 내장 비동기 함수

비동기 처리의 결과값을 이용해야할 때는 콜백함수로 전달해서 이용할 수 있다.

인수로 전달된 함수 = 콜백함수



자바스크립트 엔진은 heap, call stack으로 구성되어 있다.

heap은 변수나 상수들의 사용되는 메모리를 저장하는 영역이고,

call stack은 작성한 코드의 실행에 따라 호출 스택을 쌓는 영역이다.

콜스택에서 MainContext도 빠져가가게 되면 이는 프로그램의 종료를 의미한다.



Web APIS, Event Loop, Callback Queue

=> 자바스크립트 엔진과 웹 브라우저 간 상호작용(**비동기 등**)을 위해 존재



asyncAdd 함수 안에서 setTimeout()이라는 비동기 함수를 호출함.

setTimeout()안에는 콜백함수 cb를 포함



콜백함수에 콜백함수에 콜백함수를 넣어서 비동기 처리의 결과를 또 다른 비동기 처리의 값으로 전달할 수 있다.

비동기 처리의 결과를 또 다른 비동기 처리의 값으로 이용하는 로직이 길어지면 콜백지옥 현상을 만나게 된다.

콜백 지옥을 벗어나기 위해서 promise 객체를 이용한다.



- promise 객체 : 자바스크립트의 비동기를 돕는 객체


# 시간복잡도 & 빅오 표기법

> 알고리즘을 평가하는 스탠다드



## 좋은 코드란 무엇일까?

> Linus Torvalds - 

좋은 알고리즘이란 무엇일까?

== Input을 넣은 후 Output이 나오는 **시간**이 짧은 알고리즘!

- 알고리즘 소요 시간 측정하기 - 1

  같은 알고리즘인데 <u>컴퓨터가 달라서</u> 측정 시간이 달라질 수 있다.

  환경에 영향을 받지 않는 객관적인 기준이 필요하다

- 알고리즘 소요 시간 측정하기 - 2

  알고리즘 내부에서 <u>기본연산이 몇 번 일어나는지</u> 살펴본다.

  기본연산의 총 횟수 == 알고리즘의 소요 시간

  기본연산의 횟수를 구하는 것은 입력의 개수에 따라 시간이 달라진다는 문제가 있다.

  💡 성능을 측정할 때는 입력을 통일시킨다. 



시간 복잡도(Time Complexity)

단순하게 알고리즘의 수행 시간을 의미한다

높다 -> 느린 알고리즘

복잡도가 낮다 -> 빠른 알고리즘



빅오 표기법이란 무엇일까?

입력 n 이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것

**최고차항만 남기고 계수와 상수 제거**

정확한 수치보다는 증가율에 초점을 맞춘다.

* list comprehenshion 같은 경우의 시간 복잡도는 ?

  

이제까지는 활용법만 알았다면, 어느 정도의 시간 복잡도를 가지고 있는지 생각해보기



# 리스트 (List)

````
< 목 차 >
1. 배열 vs 연결리스트
2. 파이썬의 리스트
3. 리스트 컴프리헨션
````



## 배열 vs 연결리스트

## 파이썬의 리스트

### 파이썬 리스트의 메서드

| .append( 원소 )    | 리스트 맨 끝에 새로운 원소 삽입                              |
| ------------------ | ------------------------------------------------------------ |
| **.pop( 인덱스 )** | 특정 인덱스에 있는 원소를 **삭제** 및 <u>**반환**</u>        |
| **.count( 원소 )** | 리스트에서 해당 **원소의 개수**를 **<u>반환</u>**            |
| **.index( 원소 )** | 리스트에서 처음으로 **원소가 등장하는 인덱스**를 **<u>반환</u>** |
| **.sort()**        | **리스트를 오름차순**으로 정렬(reverse=True 옵션을 통해 내림차순으로 정렬 가능) |
| **.reverse()**     | 리스트의 **원소들의 순서를 거꾸로** 뒤집기                   |

```python
# .index(원소)에서 없는 원소를 찾을 경우

a = [1, 2, 3, 2, 5]
print(a.index(8))

ValueError: 8 is not in list
```

```python
# 리스트를 내림차순으로 정렬하기(reverse = True)

a = [5, 2, 4, 0, -1]
a.sort(reverse=True) # a.sort()만 하면 오름차순으로 정렬
print(a) # [5, 4, 2, 0, -1]
```

```python
# .reverse() 원소의 순서를 거꾸로 뒤집기

a = [1, 2, 3, 4, 5]
a.reverse()
print(a) # [5, 4, 3, 2, 1]
```



### 리스트 관련 내장함수(자주 쓰여요)

  | len(iterable)          | 리스트의 길이(원소의 개수)를 <u>반환</u>                     |
  | ---------------------- | ------------------------------------------------------------ |
  | **sum(iterable)**      | 리스트의 **모든 원소의 합**을 <u>반환</u>                    |
  | **max(iterable)**      | 리스트의 원소 중 **최대값**을 <u>반환</u>                    |
  | **min(iterable)**      | 리스트의 원소 중 **최소값**을 <u>반환</u>                    |
  | **sorted(iterable)**   | 오름차순으로 정렬된 새로운 리스트를 <u>반환</u>, 원본 리스트는 변화 없음, (내림차순 reverse=True) |
  | **reversed(iterable)** | 리스트의 순서를 거꾸로 뒤집은 **새로운** **객체** <u>반환</u>, 원본 리스트는 변화 없음 |

  ```python
  # sorted() 함수로 정렬하기(반환값을 저장할 변수가 필요해, 원본 리스트는 변하지 않으니까)
  
  a = [5, 2, -1, 0, 1]
  b = sorted(a)
  c = sorted(a, reverse = True)
  
  print(a) # 원본은 변하지 않는다. [5, 2, -1, 0, 1]
  print(b) # 오름차순 정렬 [-1, 0, 1, 2, 5]
  print(c) # 내림차순 정렬 [5, 2, 1, 0, -1]
  ```

```python
# reversed()를 쓰면 새로운 객체를 반환하므로 list형으로 바꿔서 출력해야 함.

a = [1, 2, 3, 4, 5]
b = reversed(a)
c = list(reversed(a))

print(a) # 원본은 변하지 않음 [1, 2, 3, 4, 5]
print(b) # 새로운 객체 <list_reverseiterator object at 0x0000017EA4EF3CD0>
print(c) # list형으로 변환하면 [5, 4, 3, 2, 1]
```



### 리스트 컴프리헨션(List Comprehension)

> 리스트 내포, 코드 한 줄만으로 새로운 리스트를 만드는 법이다.

```python
# 0~ 5까지 순회하면서 i를 원소로 리스트에 추가한다. 

numbers = []
for i in range(5):
    numbers.append(i)

print(numbers) # [0, 1, 2, 3, 4]
==============================================================
numbers = [i for i in range(5)]

print(numbers) # [0, 1, 2, 3, 4]
```

```python
# if문으로 필터링도 가능하다. 뒤에 if절 추가

odd_numbers = [i for i in range(10) if i%2 == 1]

print(odd_numbers) # [1, 3, 5, 7, 9]
```
